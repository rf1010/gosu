{"name":"Gosu","tagline":"Extensions to standard gosu libraries","body":"# gosu\r\nProvides extendions to standard gosu libraries.\r\n\r\n### Validation\r\n`Validation.require()`  is a syntactic sugar for validation code which throws exceptions (e.g. validating that the function input is correct). For example:\r\n```\r\nif (myParam == null) {\r\n\tthrow new IllegalArgumentException(\"myParam cannot be null\")\t\r\n} else {\r\n\t//continue program flow\r\n}\r\n```\r\nbecomes\r\n```\r\nValidation.require(\\ -> myParam != null, \"myParam cannot be null\")\r\n```\r\n\r\nThe class also allows for construction of other exceptions or executing alternative flows if the condition does not evaluate to true.\r\n\r\n### Algebraic Data Types (ATDs)\r\n#### Tuples\r\nTuple is an ordered list of elements in which elements can be of different types. The element projections (typed values) are exposed as ElementN where N ranges from 1 to max dimension or arity.  Tuples are useful as composite type constructors which contain proper equals() and hashCode() implementations, which make them usable as composite keys in HashMaps, Sets, etc. However, caution should be exercised at high arities, as tuples inhibit understanding of code (e.g. what does Tuple10.Element10 mean?).\r\n\r\nTuples can be constructed either by invoking a constructor or static builder (apply) function. Static builder function is preferable, since it uses the type system to determine the type of each element:\r\n```\r\nvar result1 = Tuple2.apply(\"A\", 1)\r\nprint (result1.Element1)   // A\r\nprint (result1.Element2)   // 1\r\n``` \r\nA constructor should be used when the type system cannot determine the type (usually when elements are blocks), in which case the element types should be defined explicitly:\r\n```\r\nvar e1 = \\ -> \"A\" // a block which returns \"A\"\r\nvar e2 = \\ -> 1   // a block which returns 1\r\n\r\nvar result2 = new Tuple2<block(): String, block(): Integer>(e1, e2)\r\nprint (result2.Element1()) // evaluate Element1() - returns \"A\"\r\nprint (result2.Element2()) // evaluate Element1() - returns 1\r\n```\r\nTuples (and tuple tests) are generated by a TupleGenerator which uses velocity templates. TupleGenerators allows customization of max dimension and some other parameters via `withXYZ()` calls, e.g. `withMaxArity(X)`. Sample TupleGenerator usage:\r\n```\r\nTupleGenerator.INSTANCE.withBasePackageName(\"com.abc\").withMaxArity(10).run()\r\n```\r\nThis will generate com.abc.gosu.functional.adt.Tuple2 to com.abc.gosu.functional.adt.Tuple10 classes and the corresponding tests.\r\n\r\nAfter the tuple classes are generated, they may be checked-in into the source control repository. Direct editing of tuple classes is discouraged.\r\n\r\n### Concurrency\r\n#### ConcurrentRunner\r\n`ConcurrentRunner` provides an implementation for parallelizing work. It allows submission of callables for execution (in separate threads). It can then optionally block the current thread until the work submitted in separate threads is completed (successfully or not (failed, time-out, etc)). `ConcurrentRunner` knows how to manage the thread pool: by default, it destroys threads after all callables are completed, but they can be set for thread re-use, if necessary.\r\n\r\nThe API is simple: \r\n`ConcurrentRunner.run()` submits callables for execution is separate threads and returns a collection of FutureResult(s).\r\n\r\n`ConcurrentRunner.collect()` blocks the thread until all callables are completed (either successfully or not). \r\n\r\n`FutureResult` can be either success or failure. Success allows to retrieve the value returned by a callable. If callable failed, FutureFailure contains the throwable which aborted the execution. If not all threads are completed prior to the timeout (the default is 60 seconds but can be overwritten), a warning is logged.\r\n\r\nSample usage:\r\n```\r\nvar doWork = \\id: Integer, delay: long -> {\r\n  Thread.sleep(delay)\r\n  return id\r\n}\r\n\r\nfastWork = (1..1000).map(\\elm -> \\ -> doWork(elm, 100)) // create 1000 threads which sleep for 0.1 second\r\n\r\nvar runner = new ConcurrentRunner<Integer>()\r\nrunner.run(fastWork)\r\nvar results = runner.collect()\r\nvar resultCount = results.whereTypeIs(gosu.concurrent.result.FutureSuccess).Count\r\nprint(resultCount) // prints the count of successful results\r\n```\r\n\r\n#### ContextAwareConcurrentRunner\r\n`ContextAwareConcurrentRunner` extends the functionality of `ConcurrentRunner` by providing the provisions to specify a bundle and/or a user which should be used for running callables. Notice that all callables are run in the same bundle and user context. By default, the user context is that of a current user, and the bundle is the \"current\" bundle, if it is writable, and a new bundle, if it is not.\r\n\r\nMost Guidewire implementations will prefer to use ContextAwareConcurrentRunner, since callables typically create new entities or modify them.\r\n\r\n### Logging\r\n`Logger` contains an implementation of org.slf4j.Logger and various predefined logging categories.\r\n\r\nSample usage:\r\n```\r\nvar logger = Logger.finder.DEV  // get development logger (logs at the trace level)\r\nlogger.debug(\\ -> \"Starting\")   // use the method with a block parameter since \r\n\t\t\t\t\t\t\t\t// the logger evaluate the block only if the debug \r\n\t\t\t\t\t\t\t\t// level or above is set (more efficient)\r\n\r\n```\r\nLogger is also \"decorated\" by a block which returns a string which gets prepended to a log message. In the provided default configuration, the log is using a stack trace element decorator which prepends the class name and function name to each log message. It can be customized to include any combination of a package name, class name, function name, file name, and a line number, or an alternative custom log decorator.\r\n\r\nIn the sample usage below, a DEV category log is instantiated with a log decorator which prepends a package name, class name, function name, file name, and the file line number to each log message:\r\n```\r\nvar customLogDecorator = \\ -> {\r\n  var stackTraceLine = StackTraceElementEnhancement\r\n        .getWithOffset_ext(3).Decorator_ext\r\n        .withStackTraceFormat(PACKAGE_CLASS_FUNCTION_FILE_LINE)\r\n        .DisplayName\r\n  return stackTraceLine != null ? stackTraceLine + \" : \" : \"\"\r\n}\r\n\r\nvar logger = Logger.finder.DEV.withDecorator(customLogDecorator)\r\nlogger.debug(\\ -> \"Started\")\r\n```\r\n\r\n\r\n\r\n### Type System\r\n`TypeSystemUtil` allows reflective construction of objects by their class names. \r\n\r\nThe example below constructs an instance of a Tuple2 class by passing class name and parameters:\r\n```\r\nvar params = { e1, e2 }.toArray()\r\nvar className = TypeSystemUtil.getClassNameFromType(Tuple2)\r\nreturn TypeSystemUtil.getInstanceByClassName(className, params) as Tuple2\r\n```\r\n\r\n### Comparators\r\n#### AssumeMatchIfTargetNotSetComparator\r\n`AssumeMatchIfTargetNotSetComparator` is the implementation which bypasses equality checks between a criteria and a target if the target is not set; it simply returns true. However, if the target is set, then the criteria must be equal to the target. Equality is assessed via a collection of functions ranging from a simple `equals()` to more sophisticated `equalsAsCaseInsensitiveString()`, `equalsAsCaseSensitiveString()`, `equalsAsCaseInsensitiveNoWhitespaceString()`, `startsWithAsCaseSensitiveString()`, etc. \r\n\r\nSample usage:\r\n```\r\nvar criteria = \"a\"\r\nvar matchAgainst = \"Abc\"\r\n\r\nvar result1 = AssumeMatchIfTargetNotSetComparator\r\n\t.buildFrom(criteria, matchAgainst).startsWithAsCaseInsensitiveString()\r\nprint (result1)  //true\r\n\r\nvar result2 = AssumeMatchIfTargetNotSetComparator\r\n\t.buildFrom(criteria, null).startsWithAsCaseInsensitiveString()\r\nprint (result2)  //true\r\n\r\nvar result3 = AssumeMatchIfTargetNotSetComparator\r\n\t.buildFrom(criteria, matchAgainst).equalsAsCaseInsensitiveString()\r\nprint (result3)  //false\r\n```\r\n\r\n#### Set Comparison\r\n`SetEnhancement` compares `that` to `this` set and returns a result which contains elements which were added, removed, or unchanged as collection properties.\r\n\r\nSample usage:\r\n```\r\nvar thisSet = { \"D\", \"B\", \"C\" }.toSet()\r\nvar thatSet = { \"A\", \"B\", \"C\", \"D\" }.toSet()\r\n\r\nvar result = thatSet.compareTo_Ext(thisSet)\r\nprint (result.Added.join(\", \"))           // A\r\nprint (result.Unchanged.join(\", \"))       // D, B, C\r\n```\r\n\r\n### Enhancements\r\n#### Iterable.firstNotNull_ext()\r\n`Iterable.firstNotNull_ext()` iterates over each element of an iterable until it finds a value which is not null. If the iterable contains blocks, evaluates blocks until it finds the one which returns a value which is not null and returns that value. \r\n\r\nSample usage:\r\n```\r\nvar result1 = { null, \"A\", \"B\" }.firstNotNull_Ext()\r\nprint (result1) // A\r\n\r\nvar a = \\ -> null as String\r\nvar b = \\ -> \"B\"\r\nvar c = \\ -> \"C\"\r\n\r\nvar result2 = { a, b, c }.firstNotNull_Ext()\r\nprint (result2) // B\r\n``` \r\n\r\n#### java.util.Date Enhancements\r\n`java.util.Date` is enhanced with static functions to calculate duration between two dates, as well as customizable user-friendly formatting, e.g. 1 Day 5 Hours 10 Minutes, etc.\r\n\r\nSample usage:\r\n```\r\nuses java.util.Date\r\n\r\nvar date1 = gw.api.util.DateUtil.currentDate()\r\nvar date2 = date1.addMinutes(65)\r\nprint (Date.getDurationAsString_Ext(date1, date2))\r\n// 1 Hour 5 Minutes 0 Seconds 0 Milliseconds 0 Microseconds 0 Nanoseconds\r\n```\r\n\r\n### Performance Measurement\r\n####Stopwatch\r\n`Stopwatch.measureExecutionDuration(runnable(): A)` allows to measure the time it takes it execute runnable and obtain its result. `Stopwatch.measureWarmedExecutionDuration(runnable(): A)` runs runnable X number of times (default is 200) to ensure that the JVM optimizations compiled it to native code and reports the results, including the speedup relative to the very first invocation.\r\n\r\nSample usage:\r\n```\r\nvar doWork = \\max: int -> {\r\n  var res: int = 0\r\n  (1..max).each(\\elt -> {\r\n    res = res + elt\r\n  })\r\n  return res\r\n}\r\n\r\nvar result = Stopwatch.measureWarmedExecutionDuration(\\ -> doWork(10000))\r\nprint (result.DurationDisplayValue)\r\n// 0 Days 0 Hours 0 Minutes 0 Seconds 6 Milliseconds 120 Microseconds 0 Nanoseconds\r\n```\r\n\r\n### Stack Trace Element Decorator\r\n`StackTraceElementEnhancement` allows the selection of a stack trace element using the offset relative to some base stack trace frame  and \"decorate\" it with additional properties, such as package name, class name, function name, etc. It is used in the logger implementation to customize the format of a log entry but can be used generically. \r\n\r\nThe stack trace element decorator should be used sparingly, as it has a performance penalty. Performance is not an issue in development environments where trace and debug level logging mode are used extensively. In a production setting, a performance penalty is mitigated by logging at a much higher log level (typically info, or error), so calls to the decorator are minimized. \r\n\r\nSee Logger for usage.\r\n\r\n```\r\nvar stackTraceLine = java.lang.StackTraceElement\r\n    .getWithOffset_Ext(1).Decorator_Ext\r\n    .withStackTraceFormat(CLASS_FUNCTION)\r\n    .DisplayName\r\n\r\nprint (stackTraceLine)\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}