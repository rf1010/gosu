{"name":"Gosu","tagline":"Extensions to standard gosu libraries","body":"# gosu\r\nProvides extendions to standard gosu libraries.\r\n\r\n### Validation\r\n`Validation.require()`  is a syntactic sugar for validation code which throws exceptions (e.g. validating that the function input is correct). For example:\r\n```\r\nif (myParam == null) {\r\n\tthrow new IllegalArgumentException(\"myParam cannot be null\")\t\r\n} else {\r\n\t//continue program flow\r\n}\r\n```\r\nbecomes\r\n```\r\nValidation.require(\\ -> myParam != null, \"myParam cannot be null\")\r\n```\r\n\r\nThe class also allows for construction of other exceptions or executing alternative flows if the condition does not evaluate to true.\r\n\r\n### Algebraic Data Types (ATDs)\r\n#### Tuples\r\nTuple is an ordered list of elements in which elements can be of different types. The element projections (typed values) are exposed as ElementN where N ranges from 1 to max dimension or arity.  Tuples are useful as composite type constructors which contain proper equals() and hashCode() implementations, which make them usable as composite keys in HashMaps, Sets, etc. However, caution should be exercised at high arities, as tuples inhibit understanding of code (e.g. what does Tuple10.Element10 mean?).\r\n\r\nTuples can be constructed either by invoking a constructor or static builder (apply) function. Static builder function is preferable, since it uses the type system to determine the type of each element:\r\n```\r\nvar result1 = Tuple2.apply(\"A\", 1)\r\nprint (result1.Element1)   // A\r\nprint (result1.Element2)   // 1\r\n``` \r\nA constructor should be used when the type system cannot determine the type (usually when elements are blocks), in which case the element types should be defined explicitly:\r\n```\r\nvar e1 = \\ -> \"A\" // a block which returns \"A\"\r\nvar e2 = \\ -> 1   // a block which returns 1\r\n\r\nvar result2 = new Tuple2<block(): String, block(): Integer>(e1, e2)\r\nprint (result2.Element1()) // evaluate Element1() - returns \"A\"\r\nprint (result2.Element2()) // evaluate Element1() - returns 1\r\n```\r\nTuples (and tuple tests) are generated by a TupleGenerator which uses velocity templates. TupleGenerators allows customization of max dimension and some other parameters via `withXYZ()` calls, e.g. `withMaxArity(X)`. Sample TupleGenerator usage:\r\n```\r\nTupleGenerator.INSTANCE.withBasePackageName(\"com.abc\").withMaxArity(10).run()\r\n```\r\nThis will generate com.abc.gosu.functional.adt.Tuple2 to com.abc.gosu.functional.adt.Tuple10 classes and the corresponding tests.\r\n\r\nAfter the tuple classes are generated, they may be checked-in into the source control repository. Direct editing of tuple classes is discouraged.\r\n\r\n### Concurrency\r\n#### ConcurrentRunner\r\n`ConcurrentRunner` provides an implementation for parallelizing work. It allows submission of callables for execution (in separate threads). It can then optionally block the current thread until the work submitted in separate threads is completed (successfully or not (failed, time-out, etc)). `ConcurrentRunner` knows how to manage the thread pool: by default, it destroys threads after all callables are completed, but they can be set for thread re-use, if necessary.\r\n\r\nThe API is simple: \r\n`ConcurrentRunner.run()` submits callables for execution is separate threads and returns a collection of FutureResult(s).\r\n\r\n`ConcurrentRunner.collect()` blocks the thread until all callables are completed (either successfully or not). \r\n\r\n`FutureResult` can be either success or failure. Success allows to retrieve the value returned by a callable. If callable failed, FutureFailure contains the throwable which aborted the execution. If not all threads are completed prior to the timeout (the default is 60 seconds but can be overwritten), a warning is logged.\r\n\r\nSample usage:\r\n```\r\nvar doWork = \\id: Integer, delay: long -> {\r\n  Thread.sleep(delay)\r\n  return id\r\n}\r\n\r\nfastWork = (1..1000).map(\\elm -> \\ -> doWork(elm, 100)) // create 1000 threads which sleep for 0.1 second\r\n\r\nvar runner = new ConcurrentRunner<Integer>()\r\nrunner.run(fastWork)\r\nvar results = runner.collect()\r\nvar resultCount = results.whereTypeIs(gosu.concurrent.result.FutureSuccess).Count\r\nprint(resultCount) // prints the count of successful results\r\n```\r\n\r\n#### ContextAwareConcurrentRunner\r\n`ContextAwareConcurrentRunner` extends the functionality of `ConcurrentRunner` by providing the provisions to specify a bundle and/or a user which should be used for running callables. Notice that all callables are run in the same bundle and user context. By default, the user context is that of a current user, and the bundle is the \"current\" bundle, if it is writable, and a new bundle, if it is not.\r\n\r\nMost Guidewire implementations will prefer to use ContextAwareConcurrentRunner, since callables typically create new entities or modify them.\r\n\r\n### Logging\r\n`Logger` contains an implementation of org.slf4j.Logger and various predefined logging categories.\r\n\r\nSample usage:\r\n```\r\nvar logger = Logger.finder.DEV  // get development logger (logs at the trace level)\r\nlogger.debug(\\ -> \"Starting\")   // use the method with a block parameter since \r\n\t\t\t\t\t\t\t\t// the logger evaluate the block only if the debug \r\n\t\t\t\t\t\t\t\t// level or above is set (more efficient)\r\n\r\n```\r\nLogger is also \"decorated\" by a block which returns a string which gets prepended to a log message. In the provided default configuration, the log is using a stack trace element decorator which prepends the class name and function name to each log message. It can be customized to include any combination of a package name, class name, function name, file name, and a line number, or an alternative custom log decorator.\r\n\r\nIn the sample usage below, a DEV category log is instantiated with a log decorator which prepends a package name, class name, function name, file name, and the file line number to each log message:\r\n```\r\nvar customLogDecorator = \\ -> {\r\n  var stackTraceLine = StackTraceElementEnhancement\r\n        .getWithOffset_ext(3).Decorator_ext\r\n        .withStackTraceFormat(PACKAGE_CLASS_FUNCTION_FILE_LINE)\r\n        .DisplayName\r\n  return stackTraceLine != null ? stackTraceLine + \" : \" : \"\"\r\n}\r\n\r\nvar logger = Logger.finder.DEV.withDecorator(customLogDecorator)\r\nlogger.debug(\\ -> \"Started\")\r\n```\r\n\r\n\r\n\r\n### Type System\r\n`TypeSystemUtil` allows reflective construction of objects by their class names. \r\n\r\nThe example below constructs an instance of a Tuple2 class by passing class name and parameters:\r\n```\r\nvar params = { e1, e2 }.toArray()\r\nvar className = TypeSystemUtil.getClassNameFromType(Tuple2)\r\nreturn TypeSystemUtil.getInstanceByClassName(className, params) as Tuple2\r\n```\r\n\r\n### Comparators\r\n#### AssumeMatchIfTargetNotSetComparator\r\n`AssumeMatchIfTargetNotSetComparator` is the implementation which bypasses equality checks between a criteria and a target if the target is not set; it simply returns true. However, if the target is set, then the criteria must be equal to the target. Equality is assessed via a collection of functions ranging from a simple `equals()` to more sophisticated `equalsAsCaseInsensitiveString()`, `equalsAsCaseSensitiveString()`, `equalsAsCaseInsensitiveNoWhitespaceString()`, `startsWithAsCaseSensitiveString()`, etc. \r\n\r\nSample usage:\r\n```\r\nvar criteria = \"a\"\r\nvar matchAgainst = \"Abc\"\r\n\r\nvar result1 = AssumeMatchIfTargetNotSetComparator\r\n\t.buildFrom(criteria, matchAgainst).startsWithAsCaseInsensitiveString()\r\nprint (result1)  //true\r\n\r\nvar result2 = AssumeMatchIfTargetNotSetComparator\r\n\t.buildFrom(criteria, null).startsWithAsCaseInsensitiveString()\r\nprint (result2)  //true\r\n\r\nvar result3 = AssumeMatchIfTargetNotSetComparator\r\n\t.buildFrom(criteria, matchAgainst).equalsAsCaseInsensitiveString()\r\nprint (result3)  //false\r\n```\r\n\r\n#### Set Comparison\r\n`SetEnhancement` compares `that` to `this` set and returns a result which contains elements which were added, removed, or unchanged as collection properties.\r\n\r\nSample usage:\r\n```\r\nvar thisSet = { \"D\", \"B\", \"C\" }.toSet()\r\nvar thatSet = { \"A\", \"B\", \"C\", \"D\" }.toSet()\r\n\r\nvar result = thatSet.compareTo_Ext(thisSet)\r\nprint (result.Added.join(\", \"))           // A\r\nprint (result.Unchanged.join(\", \"))       // D, B, C\r\n```\r\n\r\n### Enhancements\r\n#### Iterable.firstNotNull_ext()\r\n`Iterable.firstNotNull_ext()` iterates over each element of an iterable until it finds a value which is not null. If the iterable contains blocks, evaluates blocks until it finds the one which returns a value which is not null and returns that value. \r\n\r\nSample usage:\r\n```\r\nvar result1 = { null, \"A\", \"B\" }.firstNotNull_Ext()\r\nprint (result1) // A\r\n\r\nvar a = \\ -> null as String\r\nvar b = \\ -> \"B\"\r\nvar c = \\ -> \"C\"\r\n\r\nvar result2 = { a, b, c }.firstNotNull_Ext()\r\nprint (result2) // B\r\n``` \r\n\r\n#### java.util.Date Enhancements\r\n`java.util.Date` is enhanced with static functions to calculate duration between two dates, as well as customizable user-friendly formatting, e.g. 1 Day 5 Hours 10 Minutes, etc.\r\n\r\nSample usage:\r\n```\r\nuses java.util.Date\r\n\r\nvar date1 = gw.api.util.DateUtil.currentDate()\r\nvar date2 = date1.addMinutes(65)\r\nprint (Date.getDurationAsString_Ext(date1, date2))\r\n// 1 Hour 5 Minutes 0 Seconds 0 Milliseconds 0 Microseconds 0 Nanoseconds\r\n```\r\n\r\n### Performance Measurement\r\n#### Stopwatch\r\n`Stopwatch.measureExecutionDuration(runnable(): A)` allows to measure the time it takes it execute runnable and obtain its result. `Stopwatch.measureWarmedExecutionDuration(runnable(): A)` runs runnable X number of times (default is 200) to ensure that the JVM optimizations compiled it to native code and reports the results, including the speedup relative to the very first invocation.\r\n\r\nSample usage:\r\n```\r\nvar doWork = \\max: int -> {\r\n  var res: int = 0\r\n  (1..max).each(\\elt -> {\r\n    res = res + elt\r\n  })\r\n  return res\r\n}\r\n\r\nvar result = Stopwatch.measureWarmedExecutionDuration(\\ -> doWork(10000))\r\nprint (result.DurationDisplayValue)\r\n// 0 Days 0 Hours 0 Minutes 0 Seconds 6 Milliseconds 120 Microseconds 0 Nanoseconds\r\n```\r\n\r\n#### Performance Capture\r\nIn most modern applications, ongoing performance management is of a paramount concern, but the answer is not\r\nas easy as it may seem, especially, if the orchestrated process involves multiple (asynchronous) function calls.\r\n\r\nThe performance capturing tool allows you to place performance capturing code in some key strategic points, like so:\r\n```\r\nPerf.INSTANCE.measure(businessID, MyWebService, \"doProcessRequest\", \\ -> MyWebService.doProcessRequest()\r\n```\r\nIt is similar to a performance profiler provided by Guidewire, but it is different in its intent: profiling tools\r\nare used to troubleshoot problems and in this capacity their impact on performance is a secondary concern.\r\nPerformance capturing tools are meant to capture statistics with minimal impact on the system performance and is\r\ntherefore useful in Production environments.\r\n\r\nFor this reason, the performance capturing tool's implementation evaluates the \"measured\" code paths very quickly and\r\noff-loads the writing of statistics to the separate statistics capturing component. In the included reference\r\nimplementation, the performance capturing tool is writing collected performance statistics\r\nto the CSV files. The CSVWriter can be swapped for any other implementation.\r\n\r\nThe back-pressure is controlled by the size of the performance buffer (implemented as a circular buffer). If the\r\nperformance events are coming in at a very high rate, or the buffered results are not processed quickly enough,\r\nthe oldest elements are simply dropped. This may be mitigated by increasing the size of the buffer (by default,\r\nit can accommodate up to 1,000 results). The results captured in a buffer are processed by a separate background thread.\r\n\r\n#### Tool Usage\r\n```\r\nPerf.INSTANCE.measure(businessID, MyWebService, \"doProcessRequest\", \\ -> MyWebService.doProcessRequest()\r\n```\r\n\r\nThe `measure` function returns the type returned by the `\\ -> MyWebService.doProcessRequest()` block, so it is\r\nvery easy to inject this anywhere you call `MyWebService.doProcessRequest()`.\r\n\r\n`businessID` is a business identifier used to identify an event, e.g. Quote ID. It is used as an identifier on\r\nwhich the results of calling `MyWebService.doProcessRequest()` multiple times may be aggregated to calculate the\r\nmin, max, average, etc.\r\n\r\n`MyWebService` is the class being measured.\r\n\r\n`doProcessRequest` is usually the function name being measured, but can be anything, as it is represented by a string.\r\n\r\n`\\ -> MyWebService.doProcessRequest()` is a block which returns some result. This is the code which is being measured.\r\nThe results are reported in milliseconds.\r\n\r\n\r\n### Stack Trace Element Decorator\r\n`StackTraceElementEnhancement` allows the selection of a stack trace element using the offset relative to some base stack trace frame  and \"decorate\" it with additional properties, such as package name, class name, function name, etc. It is used in the logger implementation to customize the format of a log entry but can be used generically. \r\n\r\nThe stack trace element decorator should be used sparingly, as it has a performance penalty. Performance is not an issue in development environments where trace and debug level logging mode are used extensively. In a production setting, a performance penalty is mitigated by logging at a much higher log level (typically info, or error), so calls to the decorator are minimized. \r\n\r\nSee Logger for usage.\r\n\r\n```\r\nvar stackTraceLine = java.lang.StackTraceElement\r\n    .getWithOffset_Ext(1).Decorator_Ext\r\n    .withStackTraceFormat(CLASS_FUNCTION)\r\n    .DisplayName\r\n\r\nprint (stackTraceLine)\r\n```\r\n\r\n### Gosu Builder for Google Guava Cache\r\n\r\n#### What\r\nThis package contains Gosu classes which make the use of Google Guava cache from Gosu simpler\r\nfor Gosu developers, as it is using the familiar \"builder\" interface. In fact, it is a wrapper for\r\nGoogle Guava cache builder API, with sensible defaults and ability to overwrite cache parameters.\r\n\r\n#### Why\r\nGuidewire provides its own implementation of Cache in the `gw.util.concurrent.Cache` package. However,\r\nit does not provide API for defining cache eviction strategies (e.g. expire cache after 15 minutes).\r\n\r\nGoogle Guava cache implementation provides time-based eviction capabilities and therefore is more appropriate\r\nin most cases.\r\n\r\n#### How\r\nFor most common usage patterns, please see the tests (`gtest/gosu/cache/CacheTest`) and the cache implementation in\r\n`SimpleCacheImpl`. You would likely want to use a singleton pattern. SimpleCacheImpl provides a reference\r\nimplementation for the Singleton pattern in Gosu (it relies on the order of static initializers on JVM).\r\n\r\nBe careful with other Singleton patterns, such as a final static variable\r\n`\r\nfinal static var _cache: ICache = new CacheImpl()\r\n`\r\nas it does not work correctly in highly concurrent environments.\r\n\r\n#### Usage Example\r\n```\r\nvar cache = CacheBuilder\r\n    .newBuilder<Integer, String>()\r\n    .withExpireAfterAccess(15, TimeUnit.MINUTES)\r\n    .withMaxSize(10)\r\n    .withRecordCacheStatistics()\r\n    .withCacheMissHandler(\\key: Integer -> handleCacheMiss(key))\r\n    .build()\r\n```\r\n\r\n`newBuilder<Integer, String>()`: the cache will have Integer as a key, and String as a value (substitute for correct\r\ntypes in your use case\r\n\r\n`withExpireAfterAccess(15, TimeUnit.MINUTES)`: will expire cache 15 minutes after last access (i.e. will evict\r\na key-value from the cache). There are other options for eviction strategies, such as withExpireAfterWrite,\r\nwithRefreshAfterWrite. For details, please see Google Guava cache documentation:\r\nhttps://github.com/google/guava/wiki/CachesExplained\r\n\r\n`withMaxSize(10)`: the maximum size of cache (i.e. the number of unique keys).\r\n\r\n`withRecordCacheStatistics()`: activates the cache statistics which one can query at runtime (e.g. collects\r\ninformation on cache misses, hits, etc.); if activated, it is available in `Cache.stats()`. Note: this is NOT\r\nactivated by default for performance reasons. However, in most Guidewire implementations, performance won't be\r\na big issue, and this should be activated if you are using cache statistics in your code.\r\n\r\n`withCacheMissHandler`: accepts a block which takes the key as a parameter and returns the value to be cached.\r\nIt gets called every time the key is not found in cache.\r\n\r\n`build()`: returns the instance of Cache.\r\n\r\n### ClassLoaderUtil\r\nContains a variety of functions and properties to troubleshoot class loading on a JVM.\r\n\r\n`ClassLoaderUtil.LoadedClassesByClassLoader` returns the list of classes loaded by each class loader.\r\n\r\n`ClassLoaderUtil.getClassInterfaces(clz: Class)` returns the list of interfaces for a class.\r\n","google":"UA-63714592-1","note":"Don't delete this file! It's used internally to help with page regeneration."}